# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StringlinesDemoDockWidget
                                 A QGIS plugin
 creates a stringlines plot from downloaded data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-10-25
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Eithan Weiss Schonberg
        email                : eithan.schonberg@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QDateTime, Qt
# add imports
from qgis.core import (
    QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
    QgsFeatureRequest, QgsGeometry, QgsPointXY, QgsVectorLayer, QgsWkbTypes,
    QgsRectangle
)
from qgis.PyQt.QtWidgets import QMessageBox, QPushButton
from qgis.gui import QgsMapLayerComboBox, QgsMapToolEmitPoint

# UI loader unchanged
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'stringlines_dockwidget_base.ui'))


class StringlinesDemoDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(StringlinesDemoDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # New: wire UI actions
        self.refreshLayersButton.clicked.connect(self.populate_layers)
        self.createPlotButton.clicked.connect(self.on_create_plot)

        # The UI now contains QgsMapLayerComboBox instances for layer selection.
        # For backward compatibility, handle older UIs where these may still be simple QComboBox.
        try:
            # If the UI widget is a QgsMapLayerComboBox, connect its layerChanged signal.
            if isinstance(self.pointsLayerCombo, QgsMapLayerComboBox):
                try:
                    self.pointsLayerCombo.layerChanged.connect(self.on_points_maplayer_changed)
                except Exception:
                    # fall back to index-based signal if needed
                    try:
                        self.pointsLayerCombo.currentIndexChanged.connect(self.on_points_layer_changed)
                    except Exception:
                        pass
            # Similar for the line layer combo
            if isinstance(self.lineLayerCombo, QgsMapLayerComboBox):
                try:
                    self.lineLayerCombo.layerChanged.connect(self.on_line_maplayer_changed)
                except Exception:
                    try:
                        self.lineLayerCombo.currentIndexChanged.connect(self.on_line_maplayer_changed)
                    except Exception:
                        pass
        except Exception:
            # If the UI lacks these widgets for some reason, ignore and continue.
            pass

        # Add a "Pick feature" button next to the fid spin box so the user can pick a line feature
        self.pickFeatureButton = QPushButton("Pick feature")
        try:
            self.gridLayout.addWidget(self.pickFeatureButton, 2, 2)
        except Exception:
            self.verticalLayout.addWidget(self.pickFeatureButton)
        self.pickFeatureButton.clicked.connect(self.start_feature_pick)

        # map-tool state holders
        self._prev_map_tool = None
        self._pick_tool = None

        # Add a direction selector (distance grows with time / decreases with time)
        # Place it in the existing grid layout below the other controls so it can
        # be easily accessed without editing the .ui file.
        self.directionLabel = QtWidgets.QLabel("Direction:")
        self.directionCombo = QtWidgets.QComboBox()
        self.directionCombo.addItems(["Distance grows with time", "Distance decreases with time"])
        # Add to grid layout (row 7, col 0/1). The .ui file uses rows 0..6, so row 7 is free.
        try:
            self.gridLayout.addWidget(self.directionLabel, 7, 0)
            self.gridLayout.addWidget(self.directionCombo, 7, 1)
        except Exception:
            # If gridLayout is not present for some reason, fallback to adding to main layout
            try:
                self.verticalLayout.addWidget(self.directionLabel)
                self.verticalLayout.addWidget(self.directionCombo)
            except Exception:
                pass

        # Keep references to layers
        self._points_layer = None
        self._line_layer = None

        # initially populate
        self.populate_layers()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    # --- new methods ---
    def populate_layers(self):
        """Populate layer combo boxes with vector layers from the project."""
        # If the UI uses QgsMapLayerComboBox they manage available layers themselves.
        # Otherwise (older UI) populate the plain QComboBox widgets.
        try:
            if isinstance(getattr(self, 'pointsLayerCombo', None), QgsMapLayerComboBox) or \
               isinstance(getattr(self, 'lineLayerCombo', None), QgsMapLayerComboBox):
                # nothing to do: the widget updates itself
                pass
            else:
                self.pointsLayerCombo.clear()
                self.lineLayerCombo.clear()
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    # keep only vector layers
                    if isinstance(layer, QgsVectorLayer):
                        display = str(layer.name())
                        self.pointsLayerCombo.addItem(display, layer.id())
                        self.lineLayerCombo.addItem(display, layer.id())
        except Exception:
            pass
        self.statusLabel.setText("Status: layers refreshed")

    def _layer_by_id(self, layer_id):
        return QgsProject.instance().mapLayer(layer_id)

    def on_points_layer_changed(self, idx):
        """Populate field combos for the selected points layer."""
        self.timeFieldCombo.clear()
        self.trainFieldCombo.clear()
        layer_id = self.pointsLayerCombo.itemData(idx)
        if not layer_id:
            return
        layer = self._layer_by_id(layer_id)
        if layer is None:
            return
        self._points_layer = layer
        # Populate field names
        for field in layer.fields():
            self.timeFieldCombo.addItem(field.name())
            self.trainFieldCombo.addItem(field.name())

    def on_points_maplayer_changed(self, layer):
        """Called when the points QgsMapLayerComboBox changes."""
        # layer will be a QgsVectorLayer or None
        if layer is None:
            self._points_layer = None
            self.timeFieldCombo.clear()
            self.trainFieldCombo.clear()
            return
        self._points_layer = layer
        self.timeFieldCombo.clear()
        self.trainFieldCombo.clear()
        for field in layer.fields():
            self.timeFieldCombo.addItem(field.name())
            self.trainFieldCombo.addItem(field.name())

    def on_line_maplayer_changed(self, layer):
        """Called when the line QgsMapLayerComboBox changes."""
        if layer is None:
            self._line_layer = None
            return
        self._line_layer = layer
        # adjust fid spin maximum to a safe upper bound
        try:
            count = layer.featureCount()
            if count > 0:
                self.lineFeatureIdSpin.setMaximum(max(self.lineFeatureIdSpin.maximum(), count * 2))
        except Exception:
            pass

    class FeatureListDialog(QtWidgets.QDialog):
        """Dialog showing a simple list of features from a layer for the user to choose a feature id."""
        def __init__(self, layer, parent=None):
            super().__init__(parent)
            self.setWindowTitle("Select feature")
            self.resize(480, 320)
            layout = QtWidgets.QVBoxLayout(self)
            self.list = QtWidgets.QListWidget()
            layout.addWidget(self.list)
            buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
            layout.addWidget(buttons)
            buttons.accepted.connect(self.accept)
            buttons.rejected.connect(self.reject)

            self._id_map = []
            if layer is not None:
                # try to provide a helpful label: use the first non-fid field if available
                display_field = None
                try:
                    fields = [f.name() for f in layer.fields()]
                    if fields:
                        display_field = fields[0]
                except Exception:
                    display_field = None

                for feat in layer.getFeatures():
                    try:
                        label = str(feat.id())
                        if display_field and display_field in feat.fields().names():
                            label += f": {feat[display_field]}"
                        self.list.addItem(label)
                        self._id_map.append(feat.id())
                    except Exception:
                        continue

        def selected_fid(self):
            idx = self.list.currentRow()
            if idx < 0 or idx >= len(self._id_map):
                return None
            return self._id_map[idx]

    def start_feature_pick(self):
        """Activate a temporary map tool to pick a feature from the selected line layer."""
        if not getattr(self, '_line_layer', None):
            QMessageBox.warning(self, "No line layer", "Please select a line layer first.")
            return
        # open a simple feature-list dialog instead of using a map click picker
        try:
            dlg = StringlinesDemoDockWidget.FeatureListDialog(self._line_layer, parent=self)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                fid = dlg.selected_fid()
                if fid is not None:
                    # reuse existing handler to set fid and zoom/select
                    self.on_feature_picked(fid)
                    return
        except Exception:
            QMessageBox.warning(self, "Feature list error", "Failed to open feature list dialog.")
            return

    def on_feature_picked(self, fid):
        """Callback from the pick tool when the user clicked near a feature."""
        try:
            self.lineFeatureIdSpin.setValue(int(fid))
        except Exception:
            pass
        if getattr(self, '_line_layer', None):
            try:
                self._line_layer.selectByIds([fid])
                canvas = __import__('qgis.utils').iface.mapCanvas()
                extent = self._line_layer.boundingBoxOfSelected()
                if extent and not extent.isEmpty():
                    canvas.setExtent(extent)
                    canvas.refresh()
            except Exception:
                pass
        # restore previous map tool
        try:
            canvas = __import__('qgis.utils').iface.mapCanvas()
            if getattr(self, '_prev_map_tool', None) is not None:
                canvas.setMapTool(self._prev_map_tool)
        except Exception:
            pass
        self._pick_tool = None
        self._prev_map_tool = None
        self.statusLabel.setText("Status: feature picked")

    def on_create_plot(self):
        """Main routine: snap points to the chosen line, compute distance along line, and plot."""
        # get selected layers: prefer the QgsMapLayerComboBox-backed layers if present
        points_layer = getattr(self, '_points_layer', None)
        line_layer = getattr(self, '_line_layer', None)

        if points_layer is None:
            # try to get layer from QgsMapLayerComboBox first
            try:
                points_layer = self.pointsLayerCombo.currentLayer()
            except Exception:
                try:
                    p_idx = self.pointsLayerCombo.currentIndex()
                    if p_idx < 0:
                        QMessageBox.warning(self, "Missing layers", "Please select both points and line layers.")
                        return
                    points_layer = self._layer_by_id(self.pointsLayerCombo.itemData(p_idx))
                except Exception:
                    points_layer = None

        if line_layer is None:
            try:
                line_layer = self.lineLayerCombo.currentLayer()
            except Exception:
                try:
                    l_idx = self.lineLayerCombo.currentIndex()
                    if l_idx < 0:
                        QMessageBox.warning(self, "Missing layers", "Please select both points and line layers.")
                        return
                    line_layer = self._layer_by_id(self.lineLayerCombo.itemData(l_idx))
                except Exception:
                    line_layer = None
        if points_layer is None or line_layer is None:
            QMessageBox.warning(self, "Layer error", "Could not access chosen layers.")
            return

        time_field = self.timeFieldCombo.currentText()
        train_field = self.trainFieldCombo.currentText()
        tolerance_m = float(self.toleranceSpin.value())
        fid = int(self.lineFeatureIdSpin.value())

        # prepare transform to EPSG:2039
        dest_crs = QgsCoordinateReferenceSystem('EPSG:2039')
        proj_ctx = QgsProject.instance().transformContext()
        transform_points = QgsCoordinateTransform(points_layer.crs(), dest_crs, proj_ctx)
        transform_line = QgsCoordinateTransform(line_layer.crs(), dest_crs, proj_ctx)

        # get line feature (by fid if exists, otherwise first feature)
        line_feat = line_layer.getFeature(fid)
        if not line_feat.isValid():
            # fallback to first
            it = line_layer.getFeatures()
            try:
                line_feat = next(it)
            except StopIteration:
                QMessageBox.warning(self, "No features", "Line layer contains no features.")
                return

        line_geom = QgsGeometry(line_feat.geometry())
        # transform line geometry to 2039
        try:
            line_geom.transform(transform_line)
        except Exception:
            QMessageBox.warning(self, "Transform error", "Failed to transform line geometry to EPSG:2039.")
            return

        if line_geom.isEmpty() or line_geom.type() != QgsWkbTypes.LineGeometry:
            QMessageBox.warning(self, "Geometry error", "Selected feature is not a valid line geometry.")
            return

        self.statusLabel.setText("Status: snapping points...")
        snapped_by_train = {}
        total = points_layer.featureCount()
        processed = 0

        for feat in points_layer.getFeatures():
            processed += 1
            # update status simple
            if processed % 100 == 0:
                self.statusLabel.setText(f"Status: processing {processed}/{total}")

            pt_geom = QgsGeometry(feat.geometry())
            try:
                pt_geom.transform(transform_points)
            except Exception:
                continue

            if pt_geom.isEmpty():
                continue

            # compute distance to line
            dist = line_geom.distance(pt_geom)
            if dist > tolerance_m:
                continue  # disregard non-snapped points

            # compute location along line in map units
            try:
                # lineLocatePoint expects a point
                point_xy = pt_geom.asPoint()
                loc = line_geom.lineLocatePoint(QgsGeometry.fromPointXY(QgsPointXY(point_xy)))
                # loc is distance along line in map units (meters in EPSG:2039)
                dist_from_start = float(loc)
            except Exception:
                continue

            # read time and train number
            raw_time = feat[time_field] if time_field in feat.fields().names() else None
            raw_train = feat[train_field] if train_field in feat.fields().names() else None

            # parse time
            py_dt = None
            if isinstance(raw_time, QDateTime):
                py_dt = raw_time.toPyDateTime()
            else:
                # try QDateTime parsing or Python isoformat
                try:
                    qdt = QDateTime.fromString(str(raw_time), Qt.ISODate)
                    if qdt.isValid():
                        py_dt = qdt.toPyDateTime()
                    else:
                        # last resort: attempt Python fromisoformat
                        import datetime
                        py_dt = datetime.datetime.fromisoformat(str(raw_time))
                except Exception:
                    continue  # skip points without valid time

            key = raw_train if raw_train is not None else 'unknown'
            snapped_by_train.setdefault(key, []).append((py_dt, dist_from_start))

        if not snapped_by_train:
            QMessageBox.information(self, "No snapped points", "No points were snapped to the line within the given tolerance.")
            self.statusLabel.setText("Status: no snapped points")
            return

        # prepare plotly traces
        try:
            import plotly.graph_objects as go
            import plotly.io as pio
        except Exception as e:
            QMessageBox.warning(self, "Plotly missing", f"Plotly is required: {e}")
            return

        # Determine user selected direction: True => increasing (distance grows with time), False => decreasing
        sel_idx = 0
        try:
            sel_idx = int(self.directionCombo.currentIndex())
        except Exception:
            sel_idx = 0
        want_increasing = (sel_idx == 0)

        fig = go.Figure()
        plotted = 0

        def follows_direction(dlist, increasing=True):
            # Requires at least two points to determine a direction
            if not dlist or len(dlist) < 2:
                return False
            eps = 1e-6
            if increasing:
                return all((b - a) >= -eps for a, b in zip(dlist, dlist[1:]))
            else:
                return all((b - a) <= eps for a, b in zip(dlist, dlist[1:]))

        for train, recs in snapped_by_train.items():
            # sort by time
            recs_sorted = sorted(recs, key=lambda x: x[0])
            times = [r[0] for r in recs_sorted]
            dists = [r[1] for r in recs_sorted]

            # Only include journeys that follow the selected direction
            try:
                if not follows_direction(dists, increasing=want_increasing):
                    continue
            except Exception:
                # if anything goes wrong, skip this train
                continue

            # convert datetimes to ISO strings for plotly
            times_iso = [t.isoformat() for t in times]
            fig.add_trace(go.Scatter(x=times_iso, y=dists, mode='lines+markers', name=str(train)))
            plotted += 1

        if plotted == 0:
            QMessageBox.information(self, "No journeys match", "No journeys match the selected direction filter.")
            self.statusLabel.setText("Status: no journeys match direction")
            return

        # generate html for plotly figure
        html = pio.to_html(fig, include_plotlyjs='cdn', full_html=True)
        try:
            from .stringlines_plot_widget import PlotWidget
            # create as an independent top-level window (parent=None)
            w = PlotWidget(parent=None)
            w.setWindowTitle("Stringlines Plot")
            # ensure window is deleted on close and keep a reference
            w.setAttribute(Qt.WA_DeleteOnClose, True)
            self._plot_window = w
            w.load_html(html)
            w.show()
            self.statusLabel.setText("Status: plot created")
        except Exception as e:
            QMessageBox.warning(self, "Plot window error", f"Failed to open plot window: {e}")
            return
