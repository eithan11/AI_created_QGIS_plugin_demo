# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StringlinesDemoDockWidget
                                 A QGIS plugin
 creates a stringlines plot from downloaded data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-10-25
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Eithan Weiss Schonberg
        email                : eithan.schonberg@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QDateTime, Qt
# add imports
from qgis.core import (
    QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
    QgsFeatureRequest, QgsGeometry, QgsPointXY, QgsVectorLayer, QgsWkbTypes
)
from qgis.PyQt.QtWidgets import QMessageBox

# UI loader unchanged
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'stringlines_dockwidget_base.ui'))


class StringlinesDemoDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(StringlinesDemoDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # New: wire UI actions
        self.refreshLayersButton.clicked.connect(self.populate_layers)
        self.pointsLayerCombo.currentIndexChanged.connect(self.on_points_layer_changed)
        self.createPlotButton.clicked.connect(self.on_create_plot)

        # Add a direction selector (distance grows with time / decreases with time)
        # Place it in the existing grid layout below the other controls so it can
        # be easily accessed without editing the .ui file.
        self.directionLabel = QtWidgets.QLabel("Direction:")
        self.directionCombo = QtWidgets.QComboBox()
        self.directionCombo.addItems(["Distance grows with time", "Distance decreases with time"])
        # Add to grid layout (row 7, col 0/1). The .ui file uses rows 0..6, so row 7 is free.
        try:
            self.gridLayout.addWidget(self.directionLabel, 7, 0)
            self.gridLayout.addWidget(self.directionCombo, 7, 1)
        except Exception:
            # If gridLayout is not present for some reason, fallback to adding to main layout
            try:
                self.verticalLayout.addWidget(self.directionLabel)
                self.verticalLayout.addWidget(self.directionCombo)
            except Exception:
                pass

        # Keep references to layers
        self._points_layer = None
        self._line_layer = None

        # initially populate
        self.populate_layers()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    # --- new methods ---
    def populate_layers(self):
        """Populate layer combo boxes with vector layers from the project."""
        self.pointsLayerCombo.clear()
        self.lineLayerCombo.clear()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            # keep only vector layers
            if isinstance(layer, QgsVectorLayer):
                display = f"{layer.name()} ({layer.id()})"
                self.pointsLayerCombo.addItem(display, layer.id())
                self.lineLayerCombo.addItem(display, layer.id())
        self.statusLabel.setText("Status: layers refreshed")

    def _layer_by_id(self, layer_id):
        return QgsProject.instance().mapLayer(layer_id)

    def on_points_layer_changed(self, idx):
        """Populate field combos for the selected points layer."""
        self.timeFieldCombo.clear()
        self.trainFieldCombo.clear()
        layer_id = self.pointsLayerCombo.itemData(idx)
        if not layer_id:
            return
        layer = self._layer_by_id(layer_id)
        if layer is None:
            return
        self._points_layer = layer
        # Populate field names
        for field in layer.fields():
            self.timeFieldCombo.addItem(field.name())
            self.trainFieldCombo.addItem(field.name())

    def on_create_plot(self):
        """Main routine: snap points to the chosen line, compute distance along line, and plot."""
        # get selected layers
        p_idx = self.pointsLayerCombo.currentIndex()
        l_idx = self.lineLayerCombo.currentIndex()
        if p_idx < 0 or l_idx < 0:
            QMessageBox.warning(self, "Missing layers", "Please select both points and line layers.")
            return

        points_layer = self._layer_by_id(self.pointsLayerCombo.itemData(p_idx))
        line_layer = self._layer_by_id(self.lineLayerCombo.itemData(l_idx))
        if points_layer is None or line_layer is None:
            QMessageBox.warning(self, "Layer error", "Could not access chosen layers.")
            return

        time_field = self.timeFieldCombo.currentText()
        train_field = self.trainFieldCombo.currentText()
        tolerance_m = float(self.toleranceSpin.value())
        fid = int(self.lineFeatureIdSpin.value())

        # prepare transform to EPSG:2039
        dest_crs = QgsCoordinateReferenceSystem('EPSG:2039')
        proj_ctx = QgsProject.instance().transformContext()
        transform_points = QgsCoordinateTransform(points_layer.crs(), dest_crs, proj_ctx)
        transform_line = QgsCoordinateTransform(line_layer.crs(), dest_crs, proj_ctx)

        # get line feature (by fid if exists, otherwise first feature)
        line_feat = line_layer.getFeature(fid)
        if not line_feat.isValid():
            # fallback to first
            it = line_layer.getFeatures()
            try:
                line_feat = next(it)
            except StopIteration:
                QMessageBox.warning(self, "No features", "Line layer contains no features.")
                return

        line_geom = QgsGeometry(line_feat.geometry())
        # transform line geometry to 2039
        try:
            line_geom.transform(transform_line)
        except Exception:
            QMessageBox.warning(self, "Transform error", "Failed to transform line geometry to EPSG:2039.")
            return

        if line_geom.isEmpty() or line_geom.type() != QgsWkbTypes.LineGeometry:
            QMessageBox.warning(self, "Geometry error", "Selected feature is not a valid line geometry.")
            return

        self.statusLabel.setText("Status: snapping points...")
        snapped_by_train = {}
        total = points_layer.featureCount()
        processed = 0

        for feat in points_layer.getFeatures():
            processed += 1
            # update status simple
            if processed % 100 == 0:
                self.statusLabel.setText(f"Status: processing {processed}/{total}")

            pt_geom = QgsGeometry(feat.geometry())
            try:
                pt_geom.transform(transform_points)
            except Exception:
                continue

            if pt_geom.isEmpty():
                continue

            # compute distance to line
            dist = line_geom.distance(pt_geom)
            if dist > tolerance_m:
                continue  # disregard non-snapped points

            # compute location along line in map units
            try:
                # lineLocatePoint expects a point
                point_xy = pt_geom.asPoint()
                loc = line_geom.lineLocatePoint(QgsGeometry.fromPointXY(QgsPointXY(point_xy)))
                # loc is distance along line in map units (meters in EPSG:2039)
                dist_from_start = float(loc)
            except Exception:
                continue

            # read time and train number
            raw_time = feat[time_field] if time_field in feat.fields().names() else None
            raw_train = feat[train_field] if train_field in feat.fields().names() else None

            # parse time
            py_dt = None
            if isinstance(raw_time, QDateTime):
                py_dt = raw_time.toPyDateTime()
            else:
                # try QDateTime parsing or Python isoformat
                try:
                    qdt = QDateTime.fromString(str(raw_time), Qt.ISODate)
                    if qdt.isValid():
                        py_dt = qdt.toPyDateTime()
                    else:
                        # last resort: attempt Python fromisoformat
                        import datetime
                        py_dt = datetime.datetime.fromisoformat(str(raw_time))
                except Exception:
                    continue  # skip points without valid time

            key = raw_train if raw_train is not None else 'unknown'
            snapped_by_train.setdefault(key, []).append((py_dt, dist_from_start))

        if not snapped_by_train:
            QMessageBox.information(self, "No snapped points", "No points were snapped to the line within the given tolerance.")
            self.statusLabel.setText("Status: no snapped points")
            return

        # prepare plotly traces
        try:
            import plotly.graph_objects as go
            import plotly.io as pio
        except Exception as e:
            QMessageBox.warning(self, "Plotly missing", f"Plotly is required: {e}")
            return

        # Determine user selected direction: True => increasing (distance grows with time), False => decreasing
        sel_idx = 0
        try:
            sel_idx = int(self.directionCombo.currentIndex())
        except Exception:
            sel_idx = 0
        want_increasing = (sel_idx == 0)

        fig = go.Figure()
        plotted = 0

        def follows_direction(dlist, increasing=True):
            # Requires at least two points to determine a direction
            if not dlist or len(dlist) < 2:
                return False
            eps = 1e-6
            if increasing:
                return all((b - a) >= -eps for a, b in zip(dlist, dlist[1:]))
            else:
                return all((b - a) <= eps for a, b in zip(dlist, dlist[1:]))

        for train, recs in snapped_by_train.items():
            # sort by time
            recs_sorted = sorted(recs, key=lambda x: x[0])
            times = [r[0] for r in recs_sorted]
            dists = [r[1] for r in recs_sorted]

            # Only include journeys that follow the selected direction
            try:
                if not follows_direction(dists, increasing=want_increasing):
                    continue
            except Exception:
                # if anything goes wrong, skip this train
                continue

            # convert datetimes to ISO strings for plotly
            times_iso = [t.isoformat() for t in times]
            fig.add_trace(go.Scatter(x=times_iso, y=dists, mode='lines+markers', name=str(train)))
            plotted += 1

        if plotted == 0:
            QMessageBox.information(self, "No journeys match", "No journeys match the selected direction filter.")
            self.statusLabel.setText("Status: no journeys match direction")
            return

        # generate html for plotly figure
        html = pio.to_html(fig, include_plotlyjs='cdn', full_html=True)
        try:
            from .stringlines_plot_widget import PlotWidget
            # create as an independent top-level window (parent=None)
            w = PlotWidget(parent=None)
            w.setWindowTitle("Stringlines Plot")
            # ensure window is deleted on close and keep a reference
            w.setAttribute(Qt.WA_DeleteOnClose, True)
            self._plot_window = w
            w.load_html(html)
            w.show()
            self.statusLabel.setText("Status: plot created")
        except Exception as e:
            QMessageBox.warning(self, "Plot window error", f"Failed to open plot window: {e}")
            return
