# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StringlinesDemoDockWidget
                                 A QGIS plugin
 creates a stringlines plot from downloaded data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-10-25
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Eithan Weiss Schonberg
        email                : eithan.schonberg@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QDateTime, Qt
# add imports
from qgis.core import (
    QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
    QgsFeatureRequest, QgsGeometry, QgsPointXY, QgsVectorLayer, QgsWkbTypes,
    QgsRectangle
)
from qgis.core import Qgis
from qgis.PyQt.QtWidgets import QMessageBox, QPushButton
from qgis.gui import QgsMapLayerComboBox, QgsMapToolEmitPoint

# UI loader unchanged
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'stringlines_dockwidget_base.ui'))


class StringlinesDemoDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(StringlinesDemoDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # New: wire UI actions
        self.refreshLayersButton.clicked.connect(self.populate_layers)
        self.createPlotButton.clicked.connect(self.on_create_plot)

        # The UI now contains QgsMapLayerComboBox instances for layer selection.
        # For backward compatibility, handle older UIs where these may still be simple QComboBox.
        try:
            # If the UI widget is a QgsMapLayerComboBox, connect its layerChanged signal.
            if isinstance(self.pointsLayerCombo, QgsMapLayerComboBox):
                try:
                    self.pointsLayerCombo.setFilters(Qgis.LayerFilter.PointLayer)
                    self.pointsLayerCombo.layerChanged.connect(self.on_points_maplayer_changed)
                except Exception:
                    # fall back to index-based signal if needed
                    try:
                        self.pointsLayerCombo.currentIndexChanged.connect(self.on_points_layer_changed)
                    except Exception:
                        pass
            # Similar for the line layer combo
            if isinstance(self.lineLayerCombo, QgsMapLayerComboBox):
                try:
                    self.lineLayerCombo.setFilters(Qgis.LayerFilter.LineLayer)
                    self.lineLayerCombo.layerChanged.connect(self.on_line_maplayer_changed)
                except Exception:
                    try:
                        self.lineLayerCombo.currentIndexChanged.connect(self.on_line_maplayer_changed)
                    except Exception:
                        pass
        except Exception:
            # If the UI lacks these widgets for some reason, ignore and continue.
            pass

        # Add a "Pick feature" button next to the fid spin box so the user can pick a line feature
        self.pickFeatureButton = QPushButton("Pick feature")
        try:
            self.gridLayout.addWidget(self.pickFeatureButton, 2, 2)
        except Exception:
            self.verticalLayout.addWidget(self.pickFeatureButton)
        self.pickFeatureButton.clicked.connect(self.start_feature_pick)

        # map-tool state holders
        self._prev_map_tool = None
        self._pick_tool = None

        # Add a direction selector (distance grows with time / decreases with time)
        # Place it in the existing grid layout below the other controls so it can
        # be easily accessed without editing the .ui file.
        self.directionLabel = QtWidgets.QLabel("Direction:")
        self.directionCombo = QtWidgets.QComboBox()
        self.directionCombo.addItems(["Distance grows with time", "Distance decreases with time"])
        # Add to grid layout (row 7, col 0/1). The .ui file uses rows 0..6, so row 7 is free.
        try:
            self.gridLayout.addWidget(self.directionLabel, 7, 0)
            self.gridLayout.addWidget(self.directionCombo, 7, 1)
        except Exception:
            # If gridLayout is not present for some reason, fallback to adding to main layout
            try:
                self.verticalLayout.addWidget(self.directionLabel)
                self.verticalLayout.addWidget(self.directionCombo)
            except Exception:
                pass

        # Keep references to layers
        self._points_layer = None
        self._line_layer = None

        # initially populate
        self.populate_layers()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    # --- new methods ---
    def populate_layers(self):
        """Populate layer combo boxes with vector layers from the project."""
        # If the UI uses QgsMapLayerComboBox they manage available layers themselves.
        # Otherwise (older UI) populate the plain QComboBox widgets.
        try:
            if isinstance(getattr(self, 'pointsLayerCombo', None), QgsMapLayerComboBox) or \
               isinstance(getattr(self, 'lineLayerCombo', None), QgsMapLayerComboBox):
                # nothing to do: the widget updates itself
                pass
            else:
                self.pointsLayerCombo.clear()
                self.lineLayerCombo.clear()
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    # keep only vector layers
                    if isinstance(layer, QgsVectorLayer):
                        display = str(layer.name())
                        self.pointsLayerCombo.addItem(display, layer.id())
                        self.lineLayerCombo.addItem(display, layer.id())
        except Exception:
            pass
        self.statusLabel.setText("Status: layers refreshed")

    def _layer_by_id(self, layer_id):
        return QgsProject.instance().mapLayer(layer_id)

    def on_points_layer_changed(self, idx):
        """Populate field combos for the selected points layer."""
        self.timeFieldCombo.clear()
        self.trainFieldCombo.clear()
        layer_id = self.pointsLayerCombo.itemData(idx)
        if not layer_id:
            return
        layer = self._layer_by_id(layer_id)
        if layer is None:
            return
        self._points_layer = layer
        # Populate field names
        for field in layer.fields():
            self.timeFieldCombo.addItem(field.name())
            self.trainFieldCombo.addItem(field.name())

    def on_points_maplayer_changed(self, layer):
        """Called when the points QgsMapLayerComboBox changes."""
        # layer will be a QgsVectorLayer or None
        if layer is None:
            self._points_layer = None
            self.timeFieldCombo.clear()
            self.trainFieldCombo.clear()
            return
        self._points_layer = layer
        self.timeFieldCombo.clear()
        self.trainFieldCombo.clear()
        for field in layer.fields():
            self.timeFieldCombo.addItem(field.name())
            self.trainFieldCombo.addItem(field.name())

    def on_line_maplayer_changed(self, layer):
        """Called when the line QgsMapLayerComboBox changes."""
        if layer is None:
            self._line_layer = None
            return
        self._line_layer = layer
        # adjust fid spin maximum to a safe upper bound
        try:
            count = layer.featureCount()
            if count > 0:
                self.lineFeatureIdSpin.setMaximum(max(self.lineFeatureIdSpin.maximum(), count * 2))
        except Exception:
            pass

    class FeatureListDialog(QtWidgets.QDialog):
        """Dialog showing features from a layer with multiple field values in columns."""
        def __init__(self, layer, parent=None):
            super().__init__(parent)
            self.setWindowTitle("Select feature")
            self.resize(480, 320)
            layout = QtWidgets.QVBoxLayout(self)
            self.tree = QtWidgets.QTreeWidget()
            self.tree.setRootIsDecorated(False)  # no expand/collapse icons needed
            self.tree.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
            layout.addWidget(self.tree)
            buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
            layout.addWidget(buttons)
            buttons.accepted.connect(self.accept)
            buttons.rejected.connect(self.reject)

            self._id_map = []
            if layer is not None:
                # set up columns: FID plus up to 3 non-geometry fields
                headers = ["FID"]
                display_fields = []
                try:
                    for field in layer.fields():
                        if len(display_fields) >= 3:
                            break
                        # skip geometry and numeric ID fields
                        if field.type() not in [15, 16]:  # QVariant::LongLong, QVariant::Int
                            display_fields.append(field.name())
                            headers.append(field.name())
                except Exception:
                    pass
                self.tree.setHeaderLabels(headers)

                for feat in layer.getFeatures():
                    try:
                        item = QtWidgets.QTreeWidgetItem()
                        item.setText(0, str(feat.id()))  # FID column
                        # add values for the selected display fields
                        for col, field in enumerate(display_fields, start=1):
                            if field in feat.fields().names():
                                item.setText(col, str(feat[field]))
                        self.tree.addTopLevelItem(item)
                        self._id_map.append(feat.id())
                    except Exception:
                        continue
                # auto-size columns
                for i in range(len(headers)):
                    self.tree.resizeColumnToContents(i)

        def selected_fid(self):
            items = self.tree.selectedItems()
            if not items:
                return None
            idx = self.tree.indexOfTopLevelItem(items[0])
            if idx >= 0 and idx < len(self._id_map):
                return self._id_map[idx]
            return None

    def start_feature_pick(self):
        """Activate a temporary map tool to pick a feature from the selected line layer."""
        if not getattr(self, '_line_layer', None):
            QMessageBox.warning(self, "No line layer", "Please select a line layer first.")
            return
        # open a simple feature-list dialog instead of using a map click picker
        try:
            dlg = StringlinesDemoDockWidget.FeatureListDialog(self._line_layer, parent=self)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                fid = dlg.selected_fid()
                if fid is not None:
                    # reuse existing handler to set fid and zoom/select
                    self.on_feature_picked(fid)
                    return
        except Exception:
            QMessageBox.warning(self, "Feature list error", "Failed to open feature list dialog.")
            return

    def on_feature_picked(self, fid):
        """Callback from the pick tool when the user clicked near a feature."""
        try:
            self.lineFeatureIdSpin.setValue(int(fid))
        except Exception:
            pass
        if getattr(self, '_line_layer', None):
            try:
                self._line_layer.selectByIds([fid])
                canvas = __import__('qgis.utils').iface.mapCanvas()
                extent = self._line_layer.boundingBoxOfSelected()
                if extent and not extent.isEmpty():
                    canvas.setExtent(extent)
                    canvas.refresh()
            except Exception:
                pass
        # restore previous map tool
        try:
            canvas = __import__('qgis.utils').iface.mapCanvas()
            if getattr(self, '_prev_map_tool', None) is not None:
                canvas.setMapTool(self._prev_map_tool)
        except Exception:
            pass
        self._pick_tool = None
        self._prev_map_tool = None
        self.statusLabel.setText("Status: feature picked")

    def on_create_plot(self):
        """Main routine: snap points to the chosen line, compute distance along line, and plot."""
        # get selected layers: prefer the QgsMapLayerComboBox-backed layers if present
        points_layer = getattr(self, '_points_layer', None)
        line_layer = getattr(self, '_line_layer', None)

        if points_layer is None:
            # try to get layer from QgsMapLayerComboBox first
            try:
                points_layer = self.pointsLayerCombo.currentLayer()
            except Exception:
                try:
                    p_idx = self.pointsLayerCombo.currentIndex()
                    if p_idx < 0:
                        QMessageBox.warning(self, "Missing layers", "Please select both points and line layers.")
                        return
                    points_layer = self._layer_by_id(self.pointsLayerCombo.itemData(p_idx))
                except Exception:
                    points_layer = None

        if line_layer is None:
            try:
                line_layer = self.lineLayerCombo.currentLayer()
            except Exception:
                try:
                    l_idx = self.lineLayerCombo.currentIndex()
                    if l_idx < 0:
                        QMessageBox.warning(self, "Missing layers", "Please select both points and line layers.")
                        return
                    line_layer = self._layer_by_id(self.lineLayerCombo.itemData(l_idx))
                except Exception:
                    line_layer = None
        if points_layer is None or line_layer is None:
            QMessageBox.warning(self, "Layer error", "Could not access chosen layers.")
            return

        time_field = self.timeFieldCombo.currentText()
        train_field = self.trainFieldCombo.currentText()
        tolerance_m = float(self.toleranceSpin.value())
        fid = int(self.lineFeatureIdSpin.value())

        # prepare transform to EPSG:2039
        dest_crs = QgsCoordinateReferenceSystem('EPSG:2039')
        proj_ctx = QgsProject.instance().transformContext()
        transform_points = QgsCoordinateTransform(points_layer.crs(), dest_crs, proj_ctx)
        transform_line = QgsCoordinateTransform(line_layer.crs(), dest_crs, proj_ctx)

        # get line feature (by fid if exists, otherwise first feature)
        line_feat = line_layer.getFeature(fid)
        if not line_feat.isValid():
            # fallback to first
            it = line_layer.getFeatures()
            try:
                line_feat = next(it)
            except StopIteration:
                QMessageBox.warning(self, "No features", "Line layer contains no features.")
                return

        line_geom = QgsGeometry(line_feat.geometry())
        # transform line geometry to 2039
        try:
            line_geom.transform(transform_line)
        except Exception:
            QMessageBox.warning(self, "Transform error", "Failed to transform line geometry to EPSG:2039.")
            return

        if line_geom.isEmpty() or line_geom.type() != QgsWkbTypes.LineGeometry:
            QMessageBox.warning(self, "Geometry error", "Selected feature is not a valid line geometry.")
            return

        self.statusLabel.setText("Status: snapping points...")
        snapped_by_train = {}
        total = points_layer.featureCount()
        processed = 0

        for feat in points_layer.getFeatures():
            processed += 1
            # update status simple
            if processed % 100 == 0:
                self.statusLabel.setText(f"Status: processing {processed}/{total}")

            pt_geom = QgsGeometry(feat.geometry())
            try:
                pt_geom.transform(transform_points)
            except Exception:
                continue

            if pt_geom.isEmpty():
                continue

            # compute distance to line
            dist = line_geom.distance(pt_geom)
            if dist > tolerance_m:
                continue  # disregard non-snapped points

            # compute location along line in map units
            try:
                # lineLocatePoint expects a point
                point_xy = pt_geom.asPoint()
                loc = line_geom.lineLocatePoint(QgsGeometry.fromPointXY(QgsPointXY(point_xy)))
                # loc is distance along line in map units (meters in EPSG:2039)
                dist_from_start = float(loc)
            except Exception:
                continue

            # read time and train number
            raw_time = feat[time_field] if time_field in feat.fields().names() else None
            raw_train = feat[train_field] if train_field in feat.fields().names() else None

            # parse time
            py_dt = None
            if isinstance(raw_time, QDateTime):
                py_dt = raw_time.toPyDateTime()
            else:
                # try QDateTime parsing or Python isoformat
                try:
                    qdt = QDateTime.fromString(str(raw_time), Qt.ISODate)
                    if qdt.isValid():
                        py_dt = qdt.toPyDateTime()
                    else:
                        # last resort: attempt Python fromisoformat
                        import datetime
                        py_dt = datetime.datetime.fromisoformat(str(raw_time))
                except Exception:
                    continue  # skip points without valid time

            key = raw_train if raw_train is not None else 'unknown'
            snapped_by_train.setdefault(key, []).append((py_dt, dist_from_start))

        if not snapped_by_train:
            QMessageBox.information(self, "No snapped points", "No points were snapped to the line within the given tolerance.")
            self.statusLabel.setText("Status: no snapped points")
            return

        # Prepare data for charting (series list). We will pass this to PlotWidget
        # which will prefer QgsLineChartPlotWidget and fall back to Plotly HTML.
        # Determine user selected direction: True => increasing (distance grows with time)
        sel_idx = 0
        try:
            sel_idx = int(self.directionCombo.currentIndex())
        except Exception:
            sel_idx = 0
        want_increasing = (sel_idx == 0)

        def follows_direction(dlist, increasing=True):
            # Requires at least two points to determine a direction
            if not dlist or len(dlist) < 2:
                return False
            eps = 1e-6
            if increasing:
                return all((b - a) >= -eps for a, b in zip(dlist, dlist[1:]))
            else:
                return all((b - a) <= eps for a, b in zip(dlist, dlist[1:]))

        series_data = []
        plotted = 0

        for train, recs in snapped_by_train.items():
            # sort by time
            recs_sorted = sorted(recs, key=lambda x: x[0])
            times = [r[0] for r in recs_sorted]
            dists = [r[1] for r in recs_sorted]

            # Only include journeys that follow the selected direction
            try:
                if not follows_direction(dists, increasing=want_increasing):
                    continue
            except Exception:
                continue

            # convert datetimes to ISO strings for plotting
            times_iso = [t.isoformat() for t in times]
            series_data.append({'name': str(train), 'x': times_iso, 'y': dists})
            plotted += 1

        if plotted == 0:
            QMessageBox.information(self, "No journeys match", "No journeys match the selected direction filter.")
            self.statusLabel.setText("Status: no journeys match direction")
            return

        # Optionally collect stop labels as y-axis ticks if a stops layer/field is provided.
        yticks = None
        try:
            stops_layer = getattr(self, '_stops_layer', None)
            if stops_layer is not None and hasattr(self, 'stopNameFieldCombo'):
                stop_name_field = self.stopNameFieldCombo.currentText()
                if stop_name_field:
                    transform_stops = QgsCoordinateTransform(stops_layer.crs(), dest_crs, proj_ctx)
                    stop_locations = []
                    for stop in stops_layer.getFeatures():
                        try:
                            stop_geom = QgsGeometry(stop.geometry())
                            stop_geom.transform(transform_stops)
                            if stop_geom.isEmpty():
                                continue
                            point_xy = stop_geom.asPoint()
                            loc = line_geom.lineLocatePoint(QgsGeometry.fromPointXY(QgsPointXY(point_xy)))
                            name = stop[stop_name_field] if stop_name_field in stop.fields().names() else 'Unknown'
                            stop_locations.append((float(loc), str(name)))
                        except Exception:
                            continue
                    if stop_locations:
                        stop_locations.sort(key=lambda x: x[0])
                        yticks = ([loc for loc, _ in stop_locations], [name for _, name in stop_locations])
        except Exception:
            yticks = None

        # create plot window and hand data to PlotWidget
        try:
            from .stringlines_plot_widget import PlotWidget
            w = PlotWidget(parent=None)
            w.setWindowTitle("Stringlines Plot")
            w.setAttribute(Qt.WA_DeleteOnClose, True)
            self._plot_window = w
            w.load_chart({'series': series_data, 'yticks': yticks})
            w.show()
            self.statusLabel.setText("Status: plot created")
        except Exception as e:
            QMessageBox.warning(self, "Plot window error", f"Failed to open plot window: {e}")
            return
